; 322471145, 50%
; 318678620, 50%
.orig x41F4
GetNum:
	ST R0, R0_SAVE_GETNUM					; SAVE REGISTERS
	ST R1, R1_SAVE_GETNUM
	ST R2, R2_SAVE_GETNUM
	ST R3, R3_SAVE_GETNUM
	ST R4, R4_SAVE_GETNUM
	ST R5, R5_SAVE_GETNUM
	ST R6, R6_SAVE_GETNUM
	ST R7, R7_SAVE_GETNUM
	LEA R0, ENTER_NUM						; LOAD "Enter an integer number: " ON R0
	PUTS									; PRINT R0
	START_GetNum:							; START OF THE ACTUAL PROGRAM
	LD R6, OVERFLOW_INDEX					
	AND R6,R6,#0							; INITIALIZE THE OVERFLOW INDEX USING R6 
	ST R6, OVERFLOW_INDEX
	LD R6, MUL_PTR							; LOAD POINTER TO MUL ON R6
	AND R4,R4,#0							; R4 IS NOT A NUMBER INDEX
	AND R2,R2,#0							; R2 WILL BE THE END RESULT
	GETC									; GET CHATACTER
	OUT										; PRINT THE ENTERED CHARACTER
	BR ONLY_ENTER_CHECK						; CHECK IF THE FIRST CHARACTER IS "ENTER"
	AFTER_ONLY_ENTER_CHECK:					; RETURN POINT AFTER THE PREVIOUS CHECK
	BR CHECK_MINUS_TEST						; CHECK IF THE FIRST CHARACTER IS "-" (MINUS) 
	LOOP:									; START OF GETTING CHARACTERS LOOP
		GETC								; GET CHARACTER
		OUT									; PRINT THE ENTERED CHARACTER
		BR ENTER_CHECK						; CHECK IF THE CHARACTER IS "ENTER"
		AFTER_ENTER_CHECK:					; RETURN POINT AFTER PREVIOUS CHECK
		BR CHECK_NOT_NUMBER					; CHECK IF THE ENTERED CHARACTER IS A LEGAL CHARACTER (0-9)
		AFTER_NUMBER_CHECK_IN_LOOP:			; RETURN POINT AFTER PREVIOUS CHECK	
		ST R0, R0_SUB_SAVE					; SAVE R0 (ENTERED CHARACTER) IN A SUB SAVER
		ADD R0,R2,#0						; MUL USES R0 AND R1 SO WE LOAD THE RESULT FROM R2 ON TO R0 
		LD R1,TEN							; LOAD THE VALUE "10" ON TO R1
		JSRR R6								; GO TO MUL
		LD R0, R0_SUB_SAVE					; RESTORE THE ENTERED CHARACTER ON TO R0
		LD R3, ZERO_ASCII					; LOAD ON R3 THE ASCII VALUE OF "0"
		ADD R0, R0, R3						; R0=R0-R3, THIS IS TO HAVE THE DECIMAL VALUE OF THE ENTERED CHARACTER IN R0
		ADD R2, R2, R0						; R2=R2+R0, ADD THE DECIMAL VALUE OF THE ENTERED CHARACTER TO THE PREVIOUS RESULT
		BR OVERFLOW_CHECK           		; CHECK IF WE GOT OVERFLOW
		BR LOOP								; DO LOOP AGAIN
		
CHECK_MINUS_TEST:							; CHECK IF THE FIRST CHARACTER IS "-"
	LD R1,CHECK_MINUS						; LOAD ON R1 THE ASCII VALUE OF "-" (IN A NEGATIVE FORM)
	AND R5,R5,#0							; R5 WILL BE THE NEGATIVE INDEX, IF 0 THEN POSITIVE AND IF 1 THEN NEGATIVE AT THE END
	ADD R1,R1,R0							; R1=R1+R0, IF R1=0 THEN THE ENTERED CHARACTER WAS "-"
	BRz NEGATE_AT_END						; CASE 0 GO TO NEGATE_AT_END (6 LINES AFTER)
	BR CHECK_NOT_NUMBER_AFTER_MINUS_CHECK	; OTHERWISE CHECK IF THE ENTERED CHARACTER IS A LEGAL CHARACTER (0-9)
	AFTER_NUMBER_CHECK:						; RETURN POINT AFTER PREVIOUS CHECK
	LD R3,ZERO_ASCII						; LOAD ON R3 THE ASCII VALUE OF "0"
	ADD R2,R0,R3							; BECAUSE R0 WASNT "-" AND IS A LEGAL CHARACTER WE ADD ITS DECIMAL VALUE TO R2
	BR LOOP									; START GETTING CHARACTERS LOOP
	NEGATE_AT_END:							; "NEGATE_AT_END"
	AND R2,R2,#0							; INITIALIZE R2 TO 0
	ADD R5,R5,#1							; R5=1, OUR NEGATIVE FLAG IS TRUE
	BR LOOP									; START GETTING CHARACTERS LOOP

OVERFLOW_CHECK:								; OVERFLOW CHECK
	ADD R5,R5,#0							; IF OUR NEGATIVE FLAS IS FALSE THEN ENTER THE POSITIVE NUMBER OVERFLOW CHECK
	BRz OVERFLOW_CHECK_POSITIVE				; GO TO POSITIVE NUMBER OVERFLOW CHECK
	ADD R5,R5,#0							; IF OUR NEGATIVE FLAS IS TRUE THEN ENTER THE NEGATIVE NUMBER OVERFLOW CHECK
	BRp OVERFLOW_CHECK_NEGATIVE				; GO TO NEGATIVE NUMBER OVERFLOW CHECK

OVERFLOW_CHECK_POSITIVE:					; POSITIVE NUMBER OVERFLOW CHECK
	ST R2, R2_SUB_SAVE						; SAVE THE RESULT ON A SUB SAVER		
	ADD R2,R2,#0							; IN THIS CASE OUR NEGATIVE FLAG IS FALSE WHICH MEANS THAT R2 IS SUPPOSED TO BE POSITIVE, IF ITS NEGATIVE WE HAVE OVERFLOW
	BRzp LOOP                               ; CASE R2>=0 RETURN TO LOOP       
	LD R6,OVERFLOW_INDEX					; LOAD OVERFLOW FLAG LABEL ON R6
	ADD R6,R6,#1							; OVERFLOW FLAG IS NOW TRUE
	ST R6, OVERFLOW_INDEX					; STORE THE OVERFLOW FLAG IN ITS LABEL
	LD R6,MUL_PTR							; LOAD MUL POINTER ON R6 AGAIN
	BR LOOP									; RETURN TO LOOP
	
OVERFLOW_CHECK_NEGATIVE:					; NEGATIVE NUMBER OVERFLOW CHECK
	ST R2, R2_SUB_SAVE						; SAVE THE RESULT ON A SUB SAVER
	NOT R2,R2								; NEGATE R2
	ADD R2,R2,#1
	ADD R2,R2,#0							; IN THIS CASE OUR NEGATIVE FLAG IS TRUE WHICH MEANS THAT R2 IS SUPPOSED TO BE NEGATIVE, IF ITS POSITIVE WE HAVE OVERFLOW
	BRnz NEGATE_BEFORE_LOOP					; CASE NO OVERFLOW NEGATE R2 AGAIN BEFORE RETURNING TO LOOP
	LD R6,OVERFLOW_INDEX					; LOAD OVERFLOW FLAG LABEL ON R6	
	ADD R6,R6,#1							; OVERFLOW FLAG IS NOW TRUE
	ST R6, OVERFLOW_INDEX					; STORE THE OVERFLOW FLAG IN ITS LABEL
	LD R6,MUL_PTR							; LOAD MUL POINTER ON R6 AGAIN
	BR LOOP									; RETURN TO LOOP
	NEGATE_BEFORE_LOOP:						; NEGATE BEFORE LOOP
	LD R2,R2_SUB_SAVE						; RESTORE R2'S VALUE BEFORE THE OVERFLOW CHECK
	BR LOOP									; RETURN TO LOOP
	
CHECK_OVERFLOW_INDEX:						; CHECK OVERFLOW FLAG
	LD R6, OVERFLOW_INDEX					; LOAD OVERFLOW FLAG TO R6
	ADD R6,R6,#0							
	BRp OVERFLOW_OCCURED					; CASE FLAG IS TRUE GO TO "OVERFLOW_OCCURED"
	BR END_LOOP								; ELSE GO TO "END_LOOP"
	
OVERFLOW_OCCURED:							; OVERFLOW OCCURED
	LEA R0, OVERFLOW_ERROR					; LOAD OVERFLOW ERROR MESSAGE ON R0
	PUTS									; PRINT OVERFLOW ERROR MESSAGE
	BR START_GetNum							; START THE PROGRAM AGAIN 

CHECK_NOT_NUMBER:							; NOT NUMBER CHECK INSIDE THE LOOP
	ST R0, R0_SUB_SAVE						; STORE THE ENTERED CHARACTER ON A SUB SAVER
	LD R3, ZERO_ASCII						; LOAD THE ASCII VALUE OF "0" ON R3 (IN A NEGATIVE FORM)
	ADD R0,R0,R3							; R0=R0+R3
	BRn NOT_NUMBER							; CASE R0<0 THEN THE ENTERED CHARACTER IS NOT A NUMBER BETWEEN 0 AND 9 AND GO TO "NOT_NUMBER"
	LD R0, R0_SUB_SAVE						; ELSE CONTINUE CHECK AND RESTORE R0 VALUE
	LD R3, NINE_ASCII						; LOAD THE ASCII VALUE OF "9" ON R3 (IN A NEGATIVE FORM)
	ADD R0,R0,R3							; R0=R0+R3
	BRp NOT_NUMBER							; CASE R0>0 THEN THE ENTERED CHARACTER IS NOT A NUMBER BETWEEN 0 AND 9 AND GO TO "NOT_NUMBER"
	LD R0,R0_SUB_SAVE						; ELSE CONTINUE AND RESTORE R0 VALUE
	BR AFTER_NUMBER_CHECK_IN_LOOP			; RETURN TO THE RETURN POINT INSIDE THE LOOP

CHECK_NOT_NUMBER_AFTER_MINUS_CHECK:			; NOT NUMBER CHECK INSIDE THE MINUS CHECK
	ST R0, R0_SUB_SAVE						; STORE THE ENTERED CHARACTER ON A SUB SAVER
	LD R3, ZERO_ASCII						; LOAD THE ASCII VALUE OF "0" ON R3 (IN A NEGATIVE FORM)
	ADD R0,R0,R3							; R0=R0+R3
	BRn NOT_NUMBER							; CASE R0<0 THEN THE ENTERED CHARACTER IS NOT A NUMBER BETWEEN 0 AND 9 AND GO TO "NOT_NUMBER"
	LD R0, R0_SUB_SAVE						; ELSE CONTINUE CHECK AND RESTORE R0 VALUE
	LD R3, NINE_ASCII						; LOAD THE ASCII VALUE OF "9" ON R3 (IN A NEGATIVE FORM)
	ADD R0,R0,R3							; R0=R0+R3
	BRp NOT_NUMBER							; CASE R0>0 THEN THE ENTERED CHARACTER IS NOT A NUMBER BETWEEN 0 AND 9 AND GO TO "NOT_NUMBER"
	LD R0,R0_SUB_SAVE						; ELSE CONTINUE AND RESTORE R0 VALUE
	BR AFTER_NUMBER_CHECK					; RETURN TO THE RETURN POINT BEFORE THE LOOP
	
NOT_NUMBER:									; NOT NUMBER
	ADD R4,R4,#1							; NOT NUMBER FLAG (R4) IS NOW TRUE
	BR LOOP									; RETURN TO LOOP

NOT_NUMBER_MESSAGE:							; NOT NUMBER MESSAGE
	LEA R0, NOT_NUMBER_ERROR				; LOAD THE NOT NUMBER ERROR MESSAGE ON R0
	PUTS									; PRINT THE NOT NUMBER ERROR MESSAGE
	BR START_GetNum							; START THE PROGRAM AGAIN 
	
ONLY_ENTER_CHECK:							; CHECK IF THE FIRST CHARACTER IS "ENTER"
	ST R0, R0_SUB_SAVE						; STORE THE ENTERED CHARACTER ON A SUB SAVER
	LD R3,ENTER_ASCII						; LOAD THE ASCII VALUE OF "ENTER" ON R3
	ADD R0, R0, R3							; R0=R0+R3
	BRz END_LOOP							; CASE 0 GO TO END_LOOP, WHICH MEANS THE FIRST ENTERED CHARACTER WAS "0"
	LD R0,R0_SUB_SAVE						; ELSE RESTORE R0 
	BR AFTER_ONLY_ENTER_CHECK				; GO TO RETURN THE POINT BEFORE THE LOOP
	
ENTER_CHECK:								; ENTER CHECK INSIDE THE LOOP
	ST R0, R0_SUB_SAVE						; STORE THE ENTERED CHARACTER ON A SUB SAVER					
	LD R3,ENTER_ASCII						; LOAD THE ASCII VALUE OF "ENTER" ON R3
	ADD R0, R0, R3							; R0=R0+R3
	BRz CHECK_LEGAL							; CASE 0 GO TO CHECK LEGAL (CHECKS THE LEGAL CHARACTER FLAG), WHICH MEANS THE LAST ENETERED CHARACTER WAS "ENTER"
	CONTINUE_ENTER_CHECK:					; RETURN POINT AFTER CHECK LEGAL
	ADD R0, R0, #0							
	BRz CHECK_OVERFLOW_INDEX				; CASE 0 AGAIN GO TO CHECK THE OVERFLOW FLAG 
	LD R0, R0_SUB_SAVE						; ELSE RESTORE R0
	BR AFTER_ENTER_CHECK					; RETURN TO THE RETURN POINT INSIDE THE LOOP

CHECK_LEGAL:								; CHECK LEGAL
	ADD R4,R4,#0							; CHECK IF OUR LEGAL CHARACTER FLAG IS TRUE/FALSE
	BRp NOT_NUMBER_MESSAGE					; CASE TRUE GO TO NOT_NUMBER_MESSAGE
	BR CONTINUE_ENTER_CHECK					; ELSE GO TO RETURN POINT INSIDE ENTER_CHECK
	

END_LOOP:									; END LOOP 
	ADD R5,R5,#0							; CHECK THE NEGATIVE FLAG
	BRz CONTINUE							; CASE FALSE GO TO CONTINUE (3 LINES AFTER)	
	NOT R2,R2								; ELSE NEGATE R2
	ADD R2,R2,#1
	CONTINUE:
	LD R0, R0_SAVE_GETNUM					; RESTORE REGISTERS FROM SAVERS
	LD R1, R1_SAVE_GETNUM
	LD R3, R3_SAVE_GETNUM
	LD R4, R4_SAVE_GETNUM
	LD R5, R5_SAVE_GETNUM
	LD R6, R6_SAVE_GETNUM
	LD R7, R7_SAVE_GETNUM
RET
R0_SAVE_GETNUM .FILL #0						; REGISTERS SAVERS
R1_SAVE_GETNUM .FILL #0
R2_SAVE_GETNUM .FILL #0
R3_SAVE_GETNUM .FILL #0
R4_SAVE_GETNUM .FILL #0
R5_SAVE_GETNUM .FILL #0
R6_SAVE_GETNUM .FILL #0
R7_SAVE_GETNUM .FILL #0
PRINT_NEW_LINE .FILL #10					; NEW LINE ASCII VALUE
CHECK_MINUS .FILL #-45						; "-" ASCII VALUE (IN NEGATIVE FORM)
ZERO_ASCII .FILL #-48						; "0" ASCII VALUE (IN NEGATIVE FORM)
NINE_ASCII .FILL #-57						; "9" ASCII VALUE (IN NEGATIVE FORM)
ENTER_ASCII .FILL #-10						;"ENTER" ASCII VALUE (IN NEGATIVE FORM)
OVERFLOW_INDEX .FILL #0						; OVERFLOW FLAG
R0_SUB_SAVE .FILL #0						; R0 SUB SAVER
R2_SUB_SAVE .FILL #0						; R2 SUB SAVER
TEN .FILL #10								; LABEL OF DECIMAL 10
MUL_PTR .FILL X4000							; MUL POINTER LABEL
ENTER_NUM .STRINGZ "Enter an integer number: "											; ENTER A NUMBER LABEL
NOT_NUMBER_ERROR .STRINGZ "Error! You did not enter a number. Please enter again: "		; NOT A NUMBER ERROR MESSAGE LABEL
OVERFLOW_ERROR .STRINGZ "Error! Number overflowed! Please enter again: "				; OVERFLOW ERROR MESSAGE LABEL
.end